# NarrativeGen 将来の拡張機能 設計案

このドキュメントは、`NarrativeGen`のコアシステムをさらに進化させるための、将来的な機能拡張に関するアイデアと設計案をまとめたものです。

---

## 1. 論理演算子の拡張 (NOT, OR)

現在の論理エンジンは`reason`をAND条件でしか評価できません。より複雑な論理を表現するため、NOTとORを導入します。

### 機能概要

-   **NOT (`!`)**: 特定の命題が**偽であること**を条件にできるようにします。
-   **OR (`|`)**: 複数の条件のうち、**いずれか1つでも満たせば**成立するようにします。

### なぜ必要か？

-   「Aが現場にいなかった**こと**が証明された」「容疑者X **または** Yが犯人だ」といった、よりニュアンスの豊かな論理表現が可能になり、ミステリーの複雑性を飛躍的に向上させます。

### 実装案

`reason`フィールドの構文を拡張します。
- **NOT**: 命題IDの前に `!` を付けます。例: `!I_02_01`
- **OR**: 複数の命題IDを `|` で区切ります。例: `F_05_02|F_05_03`
- **組み合わせ**: カッコを使って優先順位を定義します。例: `F_01_01,(!I_02_01|I_02_02)` 
  - (意味: `F_01_01`が真、かつ (`I_02_01`が偽 または `I_02_02`が真) の場合に成立)

`LogicEngine`の`ExpandBeliefs`メソッドを、この新しい構文を解釈できる逆ポーランド記法などのパーサーを用いて拡張する必要があります。

---

## 2. 動的な確実性(Certainty)計算

現在、`certainty`はCSVに記述された静的な値です。これを、根拠となる情報の確実性に基づいて動的に計算するシステムを導入します。

### 機能概要

ある命題の確実性が、その`reason`となった命題の確実性によって決まります。例えば、不確かな情報から導かれた結論の確実性は、元の情報よりも低くなるべきです。

### なぜ必要か？

-   噂話(certainty: 0.5)と目撃証言(certainty: 0.8)から導かれる結論の「信頼性」を、システムが自動的に評価できるようになります。これにより、プレイヤーは情報の確からしさをより直感的に判断できます。

### 実装案

-   `LogicEngine`が信念を拡張する際、`believedPropositions`を`HashSet<string>`から`Dictionary<string, float>`（IDと確実性のマップ）に変更します。
-   新しい信念を追加する際、その確実性を計算します。
    -   **AND条件の場合**: 根拠となった命題の確実性のうち、**最も低い値**を採用する（あるいは乗算する）。例: `min(0.5, 0.8) -> 0.5`
    -   **OR条件の場合**: 根拠となった命題の確実性のうち、**最も高い値**を採用する。

---

## 3. キャラクター別の信念管理

現在、`LogicEngine`が持つ信念は「神の視点」の単一のものです。これを拡張し、キャラクターごとに個別の信念セット（何を知っていて、何を信じているか）を持たせます。

### 機能概要

各キャラクターが、それぞれ独立した「頭脳（信念セット）」を持ちます。キャラクターは自身が知っている（信じている）情報に基づいて行動・発言します。

### なぜ必要か？

-   **誤解とすれ違い**: キャラAは「Xが犯人」と信じているが、キャラBは「Yが犯人」と信じている、といった状況を描けます。
-   **劇的アイロニー**: プレイヤーや一部のキャラだけが知っている事実を、他のキャラクターが知らない、というサスペンスフルな状況を作り出せます。
-   **情報操作**: プレイヤーが意図的に特定のキャラクターにだけ情報を与え、その行動を操る、といったゲームプレイが可能になります。

### 実装案

-   `LogicEngine`内に`Dictionary<string, HashSet<string>> characterBeliefs` のような構造を持たせ、キャラクターIDと信念セットをマッピングします。
-   `Propositions.csv`に`recipientId`カラムを追加し、誰がその情報を得たのかを指定できるようにします。`recipientId`が`ALL`の場合は全員、特定のキャラIDならそのキャラだけが情報を得ます。

---

## 4. 状態変数システム (World State)

命題（Proposition）だけでなく、「ドアが開いている」「鍵を持っている」といった世界の状態を管理するシンプルな変数システムを導入します。

### 機能概要

`LogicEngine`がキーと値のペアで世界の変数を管理します（例: `door_A_locked = true`, `player_has_key = false`）。命題が成立するための条件として、また、命題が成立した結果として、これらの変数を参照・変更できるようにします。

### なぜ必要か？

-   物語の進行度やフラグ管理が容易になります。
-   プレイヤーの選択（例: 「Aを助ける」選択）を状態変数（`player_helped_A = true`）として記録し、後の展開に永続的な影響を与えることができます。
-   オブジェクトのインタラクション（鍵でドアを開けるなど）を論理的に記述できます。

### 実装案

`Propositions.csv`に2つの任意カラムを追加します。
-   `requires`: この命題が評価されるための前提条件となる状態変数を記述します。例: `player_has_key==true,door_A_locked==true`
-   `effects`: この命題が真と判断された場合に、変化する状態変数を記述します。例: `door_A_locked=false,gained_trust_B=true`

---

## 5. 時系列とイベントシーケンス

命題に時間や順序の概念を導入し、「Aが起こった**後に**Bが起こった」という前後関係を扱えるようにします。

### 機能概要

各命題に`timestamp`や`sequence`といった順序を示すデータを追加します。論理エンジンは「イベントXは時間5に発生した」という情報を元に、「時間3にアリバイがある」という主張の矛盾を検出できるようになります。

### なぜ必要か？

-   アリバイ工作や証言の順序の矛盾など、時間軸が重要なミステリーや物語を、より厳密に構築できます。

### 実装案

-   `Propositions.csv`に`timestamp`カラムを追加します。
-   `LogicEngine`は、矛盾検出ロジックに時間的な制約を組み込みます。例えば、「`[char_A] at [loc_X] at time 5`」と「`[char_A] at [loc_Y] at time 5`」は両立しない、と判断します。 